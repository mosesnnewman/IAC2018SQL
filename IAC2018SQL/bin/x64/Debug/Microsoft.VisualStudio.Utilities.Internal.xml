<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.VisualStudio.Utilities.Internal</name>
    </assembly>
    <members>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.AsyncHttpWebRequest">
            <summary>
            HttpWeb request wrapper
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.AsyncHttpWebRequest.Url">
            <summary>
            Gets target Url
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.AsyncHttpWebRequest.Method">
            <summary>
            Gets or sets used method (GET, HEAD, POST, PUT, DELETE, TRACE, or OPTIONS)
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.AsyncHttpWebRequest.Timeout">
            <summary>
            Gets or sets timeout for response
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.AsyncHttpWebRequest.CachePolicy">
            <summary>
            Gets or sets cache policy
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.AsyncHttpWebRequest.ContentType">
            <summary>
            Gets or sets content type. For example, "application/x-www-form-urlencoded"
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.AsyncHttpWebRequest.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Utilities.Internal.AsyncHttpWebRequest" /> class.
            </summary>
            <param name="url">Url</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.AsyncHttpWebRequest.AddHeaders(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Add HTTP headers.
            </summary>
            <param name="headers">Headers to add</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.AsyncHttpWebRequest.GetResponseAsync">
            <summary>
            Send request and get response back asynchronously.
            </summary>
            <returns>Response</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.CodeContract">
            <summary>
            CodeContract is used for validate input parameters
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.CodeContract.RequiresArgumentNotNull``1(``0,System.String)">
            <summary>
            Requires that argument is not null
            </summary>
            <typeparam name="T">type of argument</typeparam>
            <param name="value">Value</param>
            <param name="argumentName">string representation of the argument</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.CodeContract.RequiresArgumentNotEmptyOrWhitespace(System.String,System.String)">
            <summary>
            Requires that string is not empty or contains just whitespaces
            </summary>
            <param name="value">value</param>
            <param name="argumentName">string representation of the argument</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.CodeContract.RequiresArgumentNotNullAndNotEmpty(System.String,System.String)">
            <summary>
            Requires that string is not null and not empty
            </summary>
            <param name="value">value</param>
            <param name="argumentName">string representation of the argument</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.CodeContract.RequiresArgumentNotNullAndNotWhiteSpace(System.String,System.String)">
            <summary>
            Requires that argument not null and not whitespace
            </summary>
            <param name="value">value</param>
            <param name="argumentName">string representation of the argument</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.CodeContract.RequiresArgumentNotEmpty(System.Guid,System.String)">
            <summary>
            Requires that Guid is not empty
            </summary>
            <param name="guid">Guid to validate</param>
            <param name="argumentName">string representation of the argument</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.DictionaryExtensions">
            <summary>
            Several dictionary extension methods.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.DictionaryExtensions.GetOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Gets a value by the given key.
            </summary>
            <typeparam name="TK">key type</typeparam>
            <typeparam name="TV">value type</typeparam>
            <param name="dictionary">dictionary</param>
            <param name="key">key in the dictionary</param>
            <returns>default if key doesn't exist in the dictionary.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.DictionaryExtensions.AddRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1},System.Boolean)">
            <summary>
            Add one dictionary content to the another dictionary
            </summary>
            <typeparam name="TKey">type of the dictionary argument key</typeparam>
            <typeparam name="TValue">type of the dictionary argument value</typeparam>
            <param name="target">target dictionary</param>
            <param name="source">source dictionary</param>
            <param name="forceUpdate">whether we need to force update value</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.DictionaryExtensions.Remove``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0)">
            <summary>
            Remove key from the ConcurrentDictionary
            </summary>
            <typeparam name="TK">type of the dictionary argument key</typeparam>
            <typeparam name="TV">type of the dictionary argument value</typeparam>
            <param name="dictionary">dictionary</param>
            <param name="key">key</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.IAsyncHttpWebRequest">
            <summary>
            HttpWeb request wrapper interface.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.IAsyncHttpWebRequest.Url">
            <summary>
            Gets target Url
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.IAsyncHttpWebRequest.Method">
            <summary>
            Gets or sets used method (GET, HEAD, POST, PUT, DELETE, TRACE, or OPTIONS)
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.IAsyncHttpWebRequest.Timeout">
            <summary>
            Gets or sets timeout for response
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.IAsyncHttpWebRequest.CachePolicy">
            <summary>
            Gets or sets cache policy
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.IAsyncHttpWebRequest.ContentType">
            <summary>
            Gets or sets content type. For example, "application/x-www-form-urlencoded"
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IAsyncHttpWebRequest.AddHeaders(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Add HTTP headers.
            </summary>
            <param name="headers">Headers</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IAsyncHttpWebRequest.GetResponseAsync">
            <summary>
            Send request and get response back asynchronously.
            </summary>
            <returns>Response</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools">
            <summary>
            Helper class to get information from the Registry
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools.GetRegistryIntValueFromLocalMachineRoot(System.String,System.String,System.Nullable{System.Int32})">
            <summary>
            Get int registry value from the HKLM root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="defaultOnError">default value on error</param>
            <returns>current value or null in case</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools.GetRegistryIntValueFromLocalMachineRoot(System.String,System.String,System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Get int registry value from the HKLM root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>\
            <param name="use64Bit">if true, it uses the 64 bit registry, otherwise 32 bit is used</param>
            <param name="defaultOnError">default value on error</param>
            <returns>current value or null in case</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools.GetRegistryValueFromLocalMachineRoot(System.String,System.String,System.Object)">
            <summary>
            Get registry key value from the HKLM root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="defaultOnError">default value on error</param>
            <returns>current value or null in case</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools.GetRegistryValueFromLocalMachineRoot(System.String,System.String,System.Boolean,System.Object)">
            <summary>
            Get registry key value from the HKLM root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="use64Bit">if true, it uses the 64 bit registry, otherwise 32 bit is used</param>
            <param name="defaultOnError">default value on error</param>
            <returns>current value or null in case</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools.GetRegistryValueFromCurrentUserRoot(System.String,System.String,System.Object)">
            <summary>
            Get registry key value from the HKCU root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="defaultOnError">default value on error</param>
            <returns>current value or null in case</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools.SetRegistryFromCurrentUserRoot(System.String,System.String,System.Object)">
            <summary>
            Sets a value in the registry from the HKCU root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="value">value to set</param>
            <returns>true if set or false if error</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools.SetRegistryFromLocalMachineRoot(System.String,System.String,System.Object,System.Boolean)">
            <summary>
            Sets a value in the registry from the HKLM root Registry
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="value">value to set</param>
            <param name="use64Bit">optional, if set to true, it uses the 64 bit registry, otherwise defaults to 32 bit</param>
            <returns>true if set or false if error</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools2.GetRegistryValueNamesFromCurrentUserRoot(System.String)">
            <summary>
            Get the names of all values under a key in the HKCU root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <returns>Array of value names or empty</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools2.GetRegistryValueNamesFromLocalMachineRoot(System.String,System.Boolean)">
            <summary>
            Get the names of all values under a key in the HKLM root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="use64Bit">if true, it uses the 64 bit registry, otherwise 32 bit is used</param>
            <returns>Array of value names or empty</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools2.GetRegistrySubKeyNamesFromCurrentUserRoot(System.String)">
            <summary>
            Get the names of all subkeys under a key in the HKCU root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <returns>Array of value names or empty</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools2.GetRegistrySubKeyNamesFromLocalMachineRoot(System.String,System.Boolean)">
            <summary>
            Get the names of all subkeys under a key in the HKLM root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="use64Bit">if true, it uses the 64 bit registry, otherwise 32 bit is used</param>
            <returns>Array of value names or empty</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools2.DoesRegistryKeyExistInCurrentUserRoot(System.String)">
            <summary>
            Determines if a key exists in the HKCU root Registry
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <returns>True if key exists, false if it does not</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools2.DoesRegistryKeyExistInLocalMachineRoot(System.String,System.Boolean)">
            <summary>
            Determines if a key exists in the HKLM root Registry
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="use64Bit">if true, it uses the 64 bit registry, otherwise 32 bit is used</param>
            <returns>True if key exists, false if it does not</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools2.DeleteRegistryKeyFromCurrentUserRoot(System.String)">
            <summary>
            Deletes the specified registry key and all subkeys in the HKCU root Registry
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <returns>True if removed, or false if error</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools2.DeleteRegistryKeyFromLocalMachineRoot(System.String,System.Boolean)">
            <summary>
            Deletes the specified registry key and all subkeys in the HKLM root Registry
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="use64Bit">if true, it uses the 64 bit registry, otherwise 32 bit is used</param>
            <returns>True if removed, or false if error</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools2.DeleteRegistryValueFromCurrentUserRoot(System.String,System.String)">
            <summary>
            Deletes the specified registry value from a key in the HKCU root Registry
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <returns>True if removed, or false if error</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools2.DeleteRegistryValueFromLocalMachineRoot(System.String,System.String,System.Boolean)">
            <summary>
            Deletes the specified registry value from a key in the HKLM root Registry
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="use64Bit">if true, it uses the 64 bit registry, otherwise 32 bit is used</param>
            <returns>True if removed, or false if error</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools3.TryGetRegistryValueKindFromCurrentUserRoot(System.String,System.String,Microsoft.Win32.RegistryValueKind@)">
            <summary>
            Determines the kind of a property in the HKCU root registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="kind">current value kind</param>
            <returns>True on success, false on failure</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools3.TryGetRegistryValueKindFromLocalMachineRoot(System.String,System.String,Microsoft.Win32.RegistryValueKind@,System.Boolean)">
            <summary>
            Determines the kind of a property in the HKLM root registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="kind">current value kind</param>
            <param name="use64Bit">if true, it uses the 64 bit registry, otherwise 32 bit is used</param>
            <returns>True on success, false on failure</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IRegistryTools4.SetRegistryFromCurrentUserRoot(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)">
            <summary>
            Sets a value in the registry from the HKCU root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="value">value to set</param>
            <param name="valueKind">Supported RegistryValueKind's are bool, int, long/ulong which will convert to DWord, DWord, and QWord</param>
            <returns>true if set or false if error</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.ErrorCode">
            <summary>
            Possible error codes for response.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.Internal.ErrorCode.NoError">
            <summary>
            No error occurs
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.Internal.ErrorCode.NullResponse">
            <summary>
            Null response was returned.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.Internal.ErrorCode.RequestTimedOut">
            <summary>
            Request was cancelled by timeout.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.Internal.ErrorCode.WebExceptionThrown">
            <summary>
            Other web exception was thrown.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.IStreamedHttpWebResponse">
            <summary>
            HttpWeb response wrapper interface.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.IStreamedHttpWebResponse.ErrorCode">
            <summary>
            Gets response error code.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.IStreamedHttpWebResponse.ExceptionCode">
            <summary>
            Gets response exception code.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.IStreamedHttpWebResponse.StatusCode">
            <summary>
            Gets response status code.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.IStreamedHttpWebResponse.GetResponseStream">
            <summary>
            Get response as a stream.
            </summary>
            <returns>Response stream</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.FileBasedRegistry.Exists">
            <summary>
            Gets a value indicating whether the registry contains values at the given path
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.FileBasedRegistry.GetBaseCacheDirectory">
            <summary>
            Gets the Linux: XDG_CACHE_HOME or MAC Application Support directory.
            </summary>
            <returns>Path to cache directory.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.FileBasedRegistry.ConvertWinRegistryPathToMacosPath(System.String)">
            <summary>
            Converts a windows registry path to a macos file path
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.FileBasedRegistryTools">
            <summary>
            File based implementation of IRegistryTools that uses the FileBasedRegistry for Unix/MacOS.
            Machine level registry is not supported.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.FileBasedRegistryTools.GetRegistrySubKeyNamesFromCurrentUserRoot(System.String)">
            <summary>
            Get the names of all subkeys under a key in the HKCU root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <returns>Array of value names or empty</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.MacNativeMethods">
            <summary>
            Class containing all PInvoke definitions we use in the Telemetry Library that are used on macOS.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.RegistryValue">
            <summary>
            Contains a registry value that is serializable for the Mono compatible FileBasedRegistry
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.RegistryValue.Name">
            <summary>
            Gets or sets the name of the value
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.RegistryValue.Type">
            <summary>
            Gets or sets the type of the value
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.RegistryValue.Text">
            <summary>
            Gets or sets the text of the value
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.RegistryValue.Strings">
            <summary>
            Gets or sets the collection of child strings for string[] values
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.RegistryValue.Value">
            <summary>
            Gets the object value of the value that was deserialized
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryValue.FromValue(System.String,System.Object)">
            <summary>
            Creates a RegistryValue instance from the given value with the given name
            </summary>
            <param name="name">The name of the RegistryValue</param>
            <param name="value">The value assigned to the RegistryValue</param>
            <returns>Returns a new RegistryValue instance</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.RegistryValues">
            <summary>
            Contains registry values that are serializable for the Mono compatible FileBasedRegistry
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.NativeFlagsEx.ToFILE_ACCESS_FLAGS(System.IO.FileAccess)">
            <summary>
            Converts System.IO.FileAccess to Windows API FILE_ACCESS_FLAGS flags. Supports limited conversions.
            </summary>
            <param name="fileAccess">System.IO.FileAccess objects to convert.</param>
            <returns>The flag representation of FILE_ACCESS_FLAGS conversion.</returns>
            <exception cref="T:System.NotImplementedException">If the conversion that is being requested doesn't exist, this will be thrown.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.NativeFlagsEx.ToFILE_SHARE_MODE(System.IO.FileShare)">
            <summary>
            Converts System.IO.FileShare to Windows API FILE_SHARE_MODE flags. Supports limited conversions.
            </summary>
            <param name="fileShare">System.IO.FileShare object to convert.</param>
            <returns>The flag representation of FILE_SHARE_MODE conversion.</returns>
            <exception cref="T:System.NotImplementedException">If the conversion that is being requested doesn't exist, this will be thrown.</exception>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.ObjectExtensions">
            <summary>
            Object extensions methods
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ObjectExtensions.Enumerate``1(``0)">
            <summary>
            Returns an enumeration that contains only the given value.
            </summary>
            <typeparam name="T">type of value</typeparam>
            <param name="value">value itself</param>
            <returns>INumerable type with only 1 value</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ObjectExtensions.EmptyIfNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Return this enumeration in case it is not null. In case it is null return empty enumeration.
            </summary>
            <typeparam name="T">type of the values</typeparam>
            <param name="enumeration">enumeration</param>
            <returns>result</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.Platform">
            <summary>
            Determines which platform the process is running on.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.Internal.Platform.IsWindows">
            <summary>
            Returns true on Windows platform.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.Internal.Platform.IsMac">
            <summary>
            Returns true on Mac OS platforms.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Utilities.Internal.Platform.IsLinux">
            <summary>
            Returns true on Linux platforms.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.RegistryTools">
            <summary>
            Helper class to get information from the Registry
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.GetRegistryIntValueFromLocalMachineRoot(System.String,System.String,System.Nullable{System.Int32})">
            <summary>
            Get int registry value from the HKLM root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="defaultOnError">default value on error</param>
            <returns>current value or null in case</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.GetRegistryIntValueFromLocalMachineRoot(System.String,System.String,System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Get int registry value from the HKLM root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="use64Bit">if true, it uses the 64 bit registry, otherwise 32 bit is used</param>
            <param name="defaultOnError">default value on error</param>
            <returns>current value or null in case</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.GetRegistryValueFromLocalMachineRoot(System.String,System.String,System.Object)">
            <summary>
            Get registry key value from the HKLM root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="defaultOnError">default value on error</param>
            <returns>current value or null in case</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.GetRegistryValueFromLocalMachineRoot(System.String,System.String,System.Boolean,System.Object)">
            <summary>
            Get registry key value from the HKLM root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="use64Bit">if true, it uses the 64 bit registry, otherwise 32 bit is used</param>
            <param name="defaultOnError">default value on error</param>
            <returns>current value or null in case</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.GetRegistryValueFromCurrentUserRoot(System.String,System.String,System.Object)">
            <summary>
            Get registry key value from the HKCU root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="defaultOnError">default value on error</param>
            <returns>current value or null in case</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.TryGetRegistryValueKindFromCurrentUserRoot(System.String,System.String,Microsoft.Win32.RegistryValueKind@)">
            <summary>
            Determines the kind of a property in the HKCU root registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="kind">current value kind</param>
            <returns>True on success, false on failure</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.TryGetRegistryValueKindFromLocalMachineRoot(System.String,System.String,Microsoft.Win32.RegistryValueKind@,System.Boolean)">
            <summary>
            Determines the kind of a property in the HKLM root registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="kind">current value kind</param>
            <param name="use64Bit">if true, it uses the 64 bit registry, otherwise 32 bit is used</param>
            <returns>True on success, false on failure</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.GetRegistryValueNamesFromCurrentUserRoot(System.String)">
            <summary>
            Get the names of all values under a key in the HKCU root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <returns>Array of value names or empty</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.GetRegistryValueNamesFromLocalMachineRoot(System.String,System.Boolean)">
            <summary>
            Get the names of all values under a key in the HKLM root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="use64Bit">if true, it uses the 64 bit registry, otherwise 32 bit is used</param>
            <returns>Array of value names or empty</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.GetRegistrySubKeyNamesFromCurrentUserRoot(System.String)">
            <summary>
            Get the names of all subkeys under a key in the HKCU root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <returns>Array of value names or empty</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.GetRegistrySubKeyNamesFromLocalMachineRoot(System.String,System.Boolean)">
            <summary>
            Get the names of all subkeys under a key in the HKLM root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="use64Bit">if true, it uses the 64 bit registry, otherwise 32 bit is used</param>
            <returns>Array of value names or empty</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.DoesRegistryKeyExistInCurrentUserRoot(System.String)">
            <summary>
            Determines if a key exists in the HKCU root Registry
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <returns>True if key exists, false if it does not</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.DoesRegistryKeyExistInLocalMachineRoot(System.String,System.Boolean)">
            <summary>
            Determines if a key exists in the HKLM root Registry
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="use64Bit">if true, it uses the 64 bit registry, otherwise 32 bit is used</param>
            <returns>True if key exists, false if it does not</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.SetRegistryFromCurrentUserRoot(System.String,System.String,System.Object)">
            <summary>
            Sets a value in the registry from the HKCU root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="value">value to set</param>
            <returns>true if set or false if error</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.SetRegistryFromCurrentUserRoot(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)">
            <summary>
            Sets a value in the registry from the HKCU root Registry.
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="value">value to set</param>
            <param name="valueKind">RegistryValueKind type. Supported types are DWord, QWord</param>
            <returns>true if set or false if error</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.SetRegistryFromLocalMachineRoot(System.String,System.String,System.Object,System.Boolean)">
            <summary>
            Sets a value in the registry from the HKLM root Registry
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="value">value to set</param>
            <param name="use64Bit">optional, if set to true, it uses the 64 bit registry, otherwise defaults to 32 bit</param>
            <returns>true if set or false if error</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.DeleteRegistryKeyFromCurrentUserRoot(System.String)">
            <summary>
            Deletes the specified registry key and all subkeys in the HKCU root Registry
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <returns>True if removed, or false if error</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.DeleteRegistryKeyFromLocalMachineRoot(System.String,System.Boolean)">
            <summary>
            Deletes the specified registry key and all subkey sin the HKLM root Registry
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="use64Bit">if true, it uses the 64 bit registry, otherwise 32 bit is used</param>
            <returns>True if removed, or false if error</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.DeleteRegistryValueFromCurrentUserRoot(System.String,System.String)">
            <summary>
            Deletes the specified registry value from a key in the HKCU root Registry
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <returns>True if removed, or false if error</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.DeleteRegistryValueFromLocalMachineRoot(System.String,System.String,System.Boolean)">
            <summary>
            Deletes the specified registry value from a key in the HKLM root Registry
            </summary>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="use64Bit">if true, it uses the 64 bit registry, otherwise 32 bit is used</param>
            <returns>True if removed, or false if error</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.GetRegistryValue(Microsoft.Win32.RegistryKey,System.String,System.String,System.Object)">
            <summary>
            Get registry key settings int value.
            </summary>
            <param name="rootKey">Root key entry</param>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="defaultOnError">default value on error</param>
            <returns>current value or null in case</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.TryGetRegistryValueKind(Microsoft.Win32.RegistryKey,System.String,System.String,Microsoft.Win32.RegistryValueKind@)">
            <summary>
            Get registry value kind.
            </summary>
            <param name="rootKey">Root key entry</param>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="kind">current value kind</param>
            <returns>True if no error, otherwise false</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.GetRegistryValueNames(Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Get all values under a registry key. If none, an empty array is returned.
            </summary>
            <param name="rootKey">Root key entry</param>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <returns>current value or null in case</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.GetRegistrySubKeyNames(Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Get all subkeys under a registry key. If none, an empty array is returned.
            </summary>
            <param name="rootKey">Root key entry</param>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <returns>current value or null in case</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.DoesRegistryKeyExist(Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Checks if registry key exists
            </summary>
            <param name="rootKey">Root key entry</param>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <returns>current value or null in case</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.SetRegistryValue(Microsoft.Win32.RegistryKey,System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)">
            <summary>
            Set registry key settings value.
            </summary>
            <param name="rootKey">Root key entry</param>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <param name="value">value to set</param>
            <param name="valueKind">&gt;RegistryValueKind type. Supported types are DWord, QWord</param>
            <returns>true if set or false if error</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.DeleteRegistrySubKey(Microsoft.Win32.RegistryKey,System.String)">
            <summary>
            Deletes registry subkey and removes all child subkeys.
            </summary>
            <param name="rootKey">Root key entry</param>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <returns>true if deleted or false if error</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.RegistryTools.DeleteRegistryValue(Microsoft.Win32.RegistryKey,System.String,System.String)">
            <summary>
            Deletes registry value from the specified subkey.
            </summary>
            <param name="rootKey">Root key entry</param>
            <param name="regKeyPath">Path to the registry key in the format key\subkey\subsubkey</param>
            <param name="regKeyName">Variable name under the key</param>
            <returns>true if deleted or false if error</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware">
             <summary>
             Collection of File and Directory utility functions that ensure the files and folders
             being interacted upon have no Windows reparse points on their paths and that the
             paths in code match the actual paths on disk.
            
             Reparse point injection is a known/common vector of security exploits. See here
             for more general information about them:
               https://docs.microsoft.com/en-us/windows/win32/fileio/reparse-points
            
             The goal of this set of functions is to get a Windows file handle, verify that it is in the expected path and then do all file operations with the same handle. It is NOT a safe
             pattern to verify the file and then perform any additional operations using the file path as an attacker can exploit the race between the check of the file and the file operation based on
             the file path. This class of attack is known as Time-of-Check/Time-of-Use (TOCTOU). To avoid this, this class will hold the file handle and perform all operations on the handle once it has
             been deemed to be in the correct location. Since all operations are based on the file handle, we know we're modifying the file that we verified to be correct.
             </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.RequireSamePath(Microsoft.Win32.SafeHandles.SafeFileHandle,System.String)">
            <summary>
            Throws UnauthorizedAccessException if the given SafeFileHandle's canonical path is not the same as expectedPath.
            </summary>
            <param name="handle">SafeHandle to the file to check.</param>
            <param name="expectedPath">Path to check the handle against.</param>
            <exception cref="T:System.UnauthorizedAccessException">The path contains Windows Reparse Points or otherwise cannot be accessed.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.RequireNoReparsePoints(System.String,System.Boolean)">
            <summary>
            Throws UnauthorizedAccessException if the canonical path is not the same as expectedPath.
            </summary>
            <param name="expectedPath">Checks that the expectedPath is not a reparse point.</param>
            <param name="asDirectory">Specifies the check to verify a directory versus a file.</param>
            <exception cref="T:System.UnauthorizedAccessException">The given FileStream's canonical path is not the same as expectedPath.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.DeleteFile(System.String)">
            <summary>
            Deletes the specified file.
            If the file's canonical path contains Windows Reparse Points, UnauthorizedAccessException is thrown and nothing is deleted.
            </summary>
            <param name="path">Path to the file to delete.</param>
            <exception cref="T:System.UnauthorizedAccessException">The path contains Windows Reparse Points or otherwise cannot be accessed.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.MoveFile(System.String,System.String)">
            <summary>
            Moves a specified file to a new location, providing the option to specify a new file name.
            If the file's canonical path contains Windows Reparse Points, UnauthorizedAccessException is thrown.
            </summary>
            <param name="sourceFileName">Full path to the file being moved.</param>
            <param name="destFileName">Full path to the new location that the file is being moved to.</param>
            <exception cref="T:System.UnauthorizedAccessException">The path contains Windows Reparse Points or otherwise cannot be accessed.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.WriteAllText(System.String,System.String)">
            <summary>
            Creates a new file, writes the specified string to the file, and then closes the file. If the target file already exists, it is overwritten.
            If the file's canonical path contains Windows Reparse Points, UnauthorizedAccessException is thrown and nothing is written.
            </summary>
            <param name="path">Full path to the target file.</param>
            <param name="contents">Contents to write to the file.</param>
            <exception cref="T:System.UnauthorizedAccessException">The path contains Windows Reparse Points or otherwise cannot be accessed.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.CreateText(System.String)">
            <summary>
            Creates or opens a file for writing UTF-8 encoded text. If opening an existing file, the file is truncated.
            If the file's canonical path contains Windows Reparse Points, UnauthorizedAccessException is thrown and nothing is written.
            </summary>
            <param name="path">Full path to the target file.</param>
            <returns>A StreamWriter to the file being opened. Caller is responsible for disposing of the StreamWriter when operations are complete.</returns>
            <exception cref="T:System.UnauthorizedAccessException">The path contains Windows Reparse Points or otherwise cannot be accessed.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.OpenWrite(System.String)">
            <summary>
            Opens an existing file or creates a new file for writing.
            If the file's canonical path contains Windows Reparse Points, UnauthorizedAccessException is thrown.
            </summary>
            <param name="path">Full path to the target file.</param>
            <returns>A file stream to the file being opened. Caller is responsible for disposing of the file stream when operations are complete.</returns>
            <exception cref="T:System.UnauthorizedAccessException">The path contains Windows Reparse Points or otherwise cannot be accessed.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.OpenRead(System.String)">
            <summary>
            Opens an existing file for reading.
            If the file's canonical path contains Windows Reparse Points, UnauthorizedAccessException is thrown.
            </summary>
            <param name="path">Full path to the target file.</param>
            <returns>A file stream to the file being opened. Caller is responsible for disposing of the file stream when operations are complete.</returns>
            <exception cref="T:System.UnauthorizedAccessException">The path contains Windows Reparse Points or otherwise cannot be accessed.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.OpenFile(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Opens a System.IO.FileStream on the specified path, having the specified mode
            with read, write, or read/write access and the specified sharing option.
            If the file's canonical path contains Windows Reparse Points, UnauthorizedAccessException is thrown.
            OpenFile will pin the directory first before doing any file operations. If pinning the directory fails or the directory is a ReparsePoint, UnauthorizedAccessException will be thrown.
            </summary>
            <param name="path">Full path to the target file.</param>
            <param name="mode">FileMode of the operation. Supports Create, CreateNew, Open or OpenOrCreate.</param>
            <param name="access">Requested FileAccess permissions. Refer to NativeFlagsEx for what flags are supported.</param>
            <param name="share">Requested FileShare access. Refer to NativeFlagsEx for what flags are supported.</param>
            <returns>A file stream to the file being opened. Caller is responsible for disposing of the file stream when operations are complete.</returns>
            <exception cref="T:System.UnauthorizedAccessException">The path contains Windows Reparse Points or otherwise cannot be accessed.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.SetFileAttributeNormal(System.String)">
            <summary>
            Checks to see if a file can be deleted by setting FileAttribute = Normal. If unable to set attribute, then user does not have access rights
            </summary>
            <param name="path">Full path of file for attribute change</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.CreateDirectory(System.String)">
            <summary>
            Creates all directories and subdirectories in the specified path.
            If the directory's canonical path contains Windows Reparse Points, UnauthorizedAccessException is thrown.
            </summary>
            <param name="path">Full path to the target directory.</param>
            <returns>DirectoryInfo</returns>
            <exception cref="T:System.UnauthorizedAccessException">The resulting directory contains Windows Reparse Points or otherwise cannot be accessed.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.PinAndRequireNoReparsePoints(System.String,System.Boolean)">
            <summary>
            Opens a SafeFileHandle to an existing file or directory and confirms that the resulting canonical path
            matches that of the given path. The resulting SafeFileHandle is IDisposable and can be used within using
            statements to ensure that subsequent file operations are writing to paths without reparse points.
            </summary>
            <param name="expectedPath">Expected path to pin.</param>
            <param name="asDirectory">Whether it is a file or directory path.</param>
            <returns>SafeFileHandle to the file/directory that was specified.</returns>
            <exception cref="T:System.UnauthorizedAccessException">The path contains Windows Reparse Points or otherwise cannot be accessed.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.PinHandle(System.String,System.Boolean)">
            <summary>
            Takes a handle on an existing file or directory to ensure that it cannot move.
            </summary>
            <param name="fullPath">Full path to the target file or directory.</param>
            <param name="asDirectory">Whether the request is on a directory or file.</param>
            <returns>SafeFileHandle to the object referenced by fullPath.</returns>
            <exception cref="T:System.UnauthorizedAccessException">Failed to open the handle either because the file or directory did not exist or because the current user has no access.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.GetFinalPath(Microsoft.Win32.SafeHandles.SafeFileHandle)">
            <summary>
            Get the full canonical path to a given SafeFileHandle, with every reparse point expanded.
            </summary>
            <param name="handle">Handle to use to get the final path.</param>
            <returns>The final resolved path of the handle.</returns>
            <exception cref="T:System.UnauthorizedAccessException">The current user has no access.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.HasReparsePoints(Microsoft.Win32.SafeHandles.SafeFileHandle,System.String)">
            <summary>
            Checks if the file system object represented by the SafeFileHandle has a canonical path that matches the given expectedPath.
            </summary>
            <param name="safeHandle">Handle of the file/directory to check.</param>
            <param name="expectedPath">The expected path to verify the handle against.</param>
            <returns>Whether the handle's path matches the path that is passed in.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.SetDeleteOnClose(System.Runtime.InteropServices.SafeHandle)">
            <summary>
            Sets the DeleteOnClose handle attribute on the given handle.
            </summary>
            <param name="handle">File handle to set DeleteOnClose.</param>
            <exception cref="T:System.ComponentModel.Win32Exception"> If unable to set DeleteOnClose on the handle, the exception will contain the reason why.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.RenameFileByHandle(System.Runtime.InteropServices.SafeHandle,System.String)">
            <summary>
            Rename a file by handle.
            </summary>
            <param name="handle">Handle to the file that you want to rename.</param>
            <param name="targetFileName">The target name that you want the file to be changed to.</param>
            <returns>true, if the rename was successful.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.SafeCreateOrOpenFile(System.String,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Combination of Create or Open File. Attempts to create the file first and if it fails, will attempt to open the file. Calls CreateNewFile and OpenExistingFiles. This is marked safe because the methods it calls
            will verify ReparsePoints. Caller needs to Pin and verify the parent directory prior to calling this method.
            </summary>
            <param name="path">Full path to the file to create or open.</param>
            <param name="fileAccess">Requested FileAccess permissions. Refer to NativeFlagsEx for what flags are supported.</param>
            <param name="fileShare">Requested FileShare access. Refer to NativeFlagsEx for what flags are supported.</param>
            <returns>A FileStream object pointing to the file that was created or opened. Caller is responsible for disposing of the file stream.</returns>
            <exception cref="T:System.IO.IOException">If unable to create or open the file, this method will throw IOException.</exception>
            <exception cref="T:System.UnauthorizedAccessException">If the path contains reparse points, UnauthorizedAccessException is thrown.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.SafeCreateNewFile(System.String,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Creates a new file, verifies it isn't a reparse point. If it contains a reparse point, this method will set DeleteOnClose flag on the handle and dispose of the handle and then throw UnauthorizedAccessException.
            Caller needs to Pin and verify the parent directory prior to calling this method.
            </summary>
            <param name="path">Full path of file to create.</param>
            <param name="fileAccess">Requested FileAccess permissions. Refer to NativeFlagsEx for what flags are supported.</param>
            <param name="fileShare">Requested FileShare access. Refer to NativeFlagsEx for what flags are supported.</param>
            <returns>Handle to the newly created file.</returns>
            <exception cref="T:System.UnauthorizedAccessException">If the file handle is created in an unexpected location (has reparse points), this will be thrown.</exception>
            <exception cref="T:System.IO.IOException">If creation fails for some other reason (like due to the file already existing), this will be thrown.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.SafeOpenExistingFile(System.String,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Opens an existing file. This method will check if the opened file handle is the path that is specified. If it is not, UnauthorizedAccessException is thrown.
            Caller needs to Pin and verify the parent directory prior to calling this method.
            </summary>
            <param name="path">Full path of file to open.</param>
            <param name="fileAccess">Requested FileAccess permissions. Refer to NativeFlagsEx for what flags are supported.</param>
            <param name="fileShare">Requested FileShare access. Refer to NativeFlagsEx for what flags are supported.</param>
            <returns>A SafeFileHandle to the file that is opened. Caller is responsible for disposing the handle when operations are complete.</returns>
            <exception cref="T:System.UnauthorizedAccessException">If the file handle is opened in an unexpected location (has reparse points), this will be thrown.</exception>
            <exception cref="T:System.IO.IOException">If file open fails for some other reason (like due to the file not existing), this will be thrown.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.UnsafeCreateDirectoryInternal(System.String)">
            <summary>
            Creates a directory and returns a SafeFileHandle. This method does NOT check for reparse points or if the handle is valid.
            </summary>
            <param name="path">Path of the directory to be created.</param>
            <returns>SafeFileHandle to the directory that was created.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.SafeSetFileAttributesNormal(System.String)">
            <summary>
            Sets the FileAttributes of Normal on the specified file.
            If the file's canonical path contains Windows Reparse Points, UnauthorizedAccessException is thrown.'
            By placing the call within this method, it prevents the underlying Windows dll from being queried when on non-Windows machines.
            </summary>
            <param name="path">Full path to the target file.</param>
            <exception cref="T:System.UnauthorizedAccessException">The path contains Windows Reparse Points or otherwise cannot be accessed.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.ReparsePointAware.UnsafeCreateFileStub(System.String,Windows.Win32.Storage.FileSystem.FILE_ACCESS_FLAGS,Windows.Win32.Storage.FileSystem.FILE_SHARE_MODE,System.Nullable{Windows.Win32.Security.SECURITY_ATTRIBUTES},Windows.Win32.Storage.FileSystem.FILE_CREATION_DISPOSITION,Windows.Win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES,System.Runtime.InteropServices.SafeHandle)">
            <summary>
            Create a stub to prevent the CreateFile method from trying to be loaded from kernel32 on non-Windows machines. Use this method instead of calling CreateFile.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.StreamedHttpWebResponse">
            <summary>
            HttpWeb response wrapper with stream implementation.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.StreamedHttpWebResponse.ErrorCode">
            <summary>
            Gets or sets response error code.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.StreamedHttpWebResponse.ExceptionCode">
            <summary>
            Gets or sets response exception code.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.StreamedHttpWebResponse.Response">
            <summary>
            Gets or sets response itself.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Utilities.Internal.StreamedHttpWebResponse.StatusCode">
            <summary>
            Gets or sets response status code.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.StreamedHttpWebResponse.GetResponseStream">
            <summary>
            Get response as a stream.
            </summary>
            <returns>Response stream</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.StringExtensions">
            <summary>
            Extend several strings methods
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.StringExtensions.Join(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Join string together using "separator" string as separator
            </summary>
            <param name="values">string array</param>
            <param name="separator">separator string </param>
            <returns>new string</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.StringExtensions.IsNullOrWhiteSpace(System.String)">
            <summary>
            Check whether string is null or contains whitespaces only
            </summary>
            <param name="value">string to validate</param>
            <returns>result of operation</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Utilities.Internal.TaskExtensions">
            <summary>
            Task extensions
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Utilities.Internal.TaskExtensions.SwallowException(System.Threading.Tasks.Task)">
             <summary>
             Swallow exceptions for event handlers.
             http://theburningmonk.com/2012/10/c-beware-of-async-void-in-your-code/
            
             We need to read an Exception to prevent throwing an Exception for
             .NET 4.0 and below. See
             http://stackoverflow.com/questions/25691114/where-does-an-async-task-throw-exception-if-it-is-not-awaited
             </summary>
             <param name="task">Task to swallow exception for</param>
        </member>
        <member name="T:Windows.Win32.Foundation.PCWSTR">
            <summary>
            A pointer to a constant character string.
            </summary>
        </member>
        <member name="F:Windows.Win32.Foundation.PCWSTR.Value">
            <summary>
            A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
            </summary>
        </member>
        <member name="P:Windows.Win32.Foundation.PCWSTR.Length">
            <summary>
            Gets the number of characters up to the first null character (exclusive).
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PCWSTR.ToString">
            <summary>
            Returns a <see langword="string" /> with a copy of this character array.
            </summary>
            <returns>A <see langword="string" />, or <see langword="null" /> if <see cref="F:Windows.Win32.Foundation.PCWSTR.Value" /> is <see langword="null" />.</returns>
        </member>
        <member name="M:Windows.Win32.Foundation.PCWSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string.
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PWSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string.
            </summary>
        </member>
        <member name="T:Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION">
            <summary>Contains information that the GetFileInformationByHandle function retrieves.</summary>
            <remarks>
            <para>The identifier that is stored in the <b>nFileIndexHigh</b> and <b>nFileIndexLow</b> members is called the file ID. Support for file IDs is file system-specific. File IDs are not guaranteed to be unique over time, because file systems are free to reuse them. In some cases, the file ID for a file can change over time. In the FAT file system, the file ID is generated from the first cluster of the containing directory and the byte offset within the directory of the entry for the file. Some defragmentation products change this byte offset. (Windows in-box defragmentation does not.) Thus, a FAT file ID can change over time. Renaming a file in the FAT file system can also change the file ID, but only if the new file name is longer than the old one. In the NTFS file system, a file keeps the same file ID until it is deleted. You can replace one file with another file without changing the file ID by using the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-replacefilea">ReplaceFile</a> function. However, the file ID of the replacement file, not the replaced file, is retained as the file ID of the resulting file. Not all file systems can record creation and last access time, and not all file systems record them in the same manner. For example, on a Windows FAT file system, create time has a resolution of 10 milliseconds, write time has a resolution of 2 seconds, and access time has a resolution of 1 day (the access date). On the NTFS file system, access time has a resolution of 1 hour. For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/file-times">File Times</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/ns-fileapi-by_handle_file_information#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION.dwFileAttributes">
            <summary>
            <para>The file attributes. For possible values and their descriptions, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/ns-fileapi-by_handle_file_information#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION.ftCreationTime">
            <summary>
            <para>A <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that specifies when a file or directory is created. If the underlying file system does not support creation time, this member is zero (0).</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/ns-fileapi-by_handle_file_information#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION.ftLastAccessTime">
            <summary>
            <para>A <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure. For a file, the structure specifies the last time that a file is read from or written to. For a directory, the structure specifies when the directory is created. For both files and directories, the specified date is correct, but the time of day is always set to midnight. If the underlying file system does not support the last access time, this member is zero (0).</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/ns-fileapi-by_handle_file_information#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION.ftLastWriteTime">
            <summary>
            <para>A <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure. For a file, the structure specifies the last time that a file is written to. For a directory, the structure specifies when the directory is created. If the underlying file system does not support the last write time, this member is zero (0).</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/ns-fileapi-by_handle_file_information#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION.dwVolumeSerialNumber">
            <summary>The serial number of the volume that contains a file.</summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION.nFileSizeHigh">
            <summary>The high-order part of the file size.</summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION.nFileSizeLow">
            <summary>The low-order part of the file size.</summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION.nNumberOfLinks">
            <summary>
            <para>The number of links to this file. For the FAT file system this member is always 1. For the NTFS file system, it can be more than 1.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/ns-fileapi-by_handle_file_information#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION.nFileIndexHigh">
            <summary>
            <para>The high-order part of a unique identifier that is associated with a file. For more information, see <b>nFileIndexLow</b>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/ns-fileapi-by_handle_file_information#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION.nFileIndexLow">
            <summary>
            <para>The low-order part of a unique identifier that is associated with a file. The identifier (low and high parts) and the volume serial number uniquely identify a file on a single computer. To determine whether two open handles represent the same file, combine the identifier and the volume serial number for each file and compare them. The ReFS file system, introduced with Windows Server2012, includes 128-bit file identifiers. To retrieve the 128-bit file identifier use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfileinformationbyhandleex">GetFileInformationByHandleEx</a> function with <b>FileIdInfo</b> to retrieve the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_info">FILE_ID_INFO</a> structure. The 64-bit identifier in this structure is not guaranteed to be unique on ReFS.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/ns-fileapi-by_handle_file_information#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.Storage.FileSystem.FILE_BASIC_INFO">
            <summary>Contains the basic information for a file. Used for file handles.</summary>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/ns-winbase-file_basic_info">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_BASIC_INFO.CreationTime">
            <summary>
            <para>The time the file was created in <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> format, which is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC).</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/ns-winbase-file_basic_info#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_BASIC_INFO.LastAccessTime">
            <summary>
            <para>The time the file was last accessed in <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> format.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/ns-winbase-file_basic_info#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_BASIC_INFO.LastWriteTime">
            <summary>
            <para>The time the file was last written to in <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> format.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/ns-winbase-file_basic_info#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_BASIC_INFO.ChangeTime">
            <summary>
            <para>The time the file was changed in <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> format.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/ns-winbase-file_basic_info#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_BASIC_INFO.FileAttributes">
            <summary>
            <para>The file attributes. For a list of attributes, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>. If this is set to 0 in a <b>FILE_BASIC_INFO</b> structure passed to <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileinformationbyhandle">SetFileInformationByHandle</a> then none of the attributes are changed.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/ns-winbase-file_basic_info#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="T:Windows.Win32.Storage.FileSystem.FILE_DISPOSITION_INFO">
            <summary>Indicates whether a file should be deleted. Used for any handles.</summary>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/ns-winbase-file_disposition_info">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS">
            <summary>Identifies the type of file information that GetFileInformationByHandleEx should retrieve or SetFileInformationByHandle should set.</summary>
            <remarks>
            <para>As noted in the preceding section, some file information classes are valid only for use with <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfileinformationbyhandleex">GetFileInformationByHandleEx</a>. Others are valid only for use with <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileinformationbyhandle">SetFileInformationByHandle</a>. Where neither function is mentioned, the information class is valid with both functions.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileBasicInfo">
            <summary>
            <para>Minimal information for the file should be retrieved or set. Used for file handles. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_basic_info">FILE_BASIC_INFO</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileStandardInfo">
            <summary>
            <para>Extended information for the file should be retrieved. Used for file handles. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfileinformationbyhandleex">GetFileInformationByHandleEx</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_standard_info">FILE_STANDARD_INFO</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileNameInfo">
            <summary>
            <para>The file name should be retrieved. Used for any handles. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfileinformationbyhandleex">GetFileInformationByHandleEx</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_name_info">FILE_NAME_INFO</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileRenameInfo">
            <summary>
            <para>The file name should be changed. Used for file handles. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileinformationbyhandle">SetFileInformationByHandle</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_rename_info">FILE_RENAME_INFO</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileDispositionInfo">
            <summary>
            <para>The file should be deleted. Used for any handles. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileinformationbyhandle">SetFileInformationByHandle</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_disposition_info">FILE_DISPOSITION_INFO</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileAllocationInfo">
            <summary>
            <para>The file allocation information should be changed. Used for file handles. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileinformationbyhandle">SetFileInformationByHandle</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_allocation_info">FILE ALLOCATION INFO</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileEndOfFileInfo">
            <summary>
            <para>The end of the file should be set. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileinformationbyhandle">SetFileInformationByHandle</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_end_of_file_info">FILE_END_OF_FILE_INFO</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileStreamInfo">
            <summary>
            <para>File stream information for the specified file should be retrieved. Used for any handles. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfileinformationbyhandleex">GetFileInformationByHandleEx</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_stream_info">FILE_STREAM_INFO</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileCompressionInfo">
            <summary>
            <para>File compression information should be retrieved. Used for any handles. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfileinformationbyhandleex">GetFileInformationByHandleEx</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_compression_info">FILE_COMPRESSION_INFO</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileAttributeTagInfo">
            <summary>
            <para>File attribute information should be retrieved. Used for any handles. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfileinformationbyhandleex">GetFileInformationByHandleEx</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_attribute_tag_info">FILE_ATTRIBUTE_TAG_INFO</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileIdBothDirectoryInfo">
            <summary>
            <para>Files in the specified directory should be retrieved. Used for directory handles. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfileinformationbyhandleex">GetFileInformationByHandleEx</a>. The number of files returned for each call to <b>GetFileInformationByHandleEx</b> depends on the size of the buffer that is passed to the function. Any subsequent calls to <b>GetFileInformationByHandleEx</b> on the same handle will resume the enumeration operation after the last file is returned. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_both_dir_info">FILE_ID_BOTH_DIR_INFO</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileIdBothDirectoryRestartInfo">
            <summary>
            <para>Identical to <b>FileIdBothDirectoryInfo</b>, but forces the enumeration operation to start again from the beginning. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_both_dir_info">FILE_ID_BOTH_DIR_INFO</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileIoPriorityHintInfo">
            <summary>
            <para>Priority hint information should be  set. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileinformationbyhandle">SetFileInformationByHandle</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_io_priority_hint_info">FILE_IO_PRIORITY_HINT_INFO</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileRemoteProtocolInfo">
            <summary>
            <para>File remote protocol information should be retrieved. Use for any handles. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfileinformationbyhandleex">GetFileInformationByHandleEx</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_remote_protocol_info">FILE_REMOTE_PROTOCOL_INFO</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileFullDirectoryInfo">
            <summary>
            <para>Files in the specified directory should be retrieved. Used for directory handles. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfileinformationbyhandleex">GetFileInformationByHandleEx</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_full_dir_info">FILE_FULL_DIR_INFO</a>. <b>Windows Server2008R2, Windows7, Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP:</b>This value is not supported before Windows8 and Windows Server2012</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileFullDirectoryRestartInfo">
            <summary>
            <para>Identical to <b>FileFullDirectoryInfo</b>, but forces the enumeration operation to start again from the beginning. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfileinformationbyhandleex">GetFileInformationByHandleEx</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_full_dir_info">FILE_FULL_DIR_INFO</a>. <b>Windows Server2008R2, Windows7, Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP:</b>This value is not supported before Windows8 and Windows Server2012</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileStorageInfo">
            <summary>
            <para>File storage information should be retrieved. Use for any handles. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfileinformationbyhandleex">GetFileInformationByHandleEx</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_storage_info">FILE_STORAGE_INFO</a>. <b>Windows Server2008R2, Windows7, Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP:</b>This value is not supported before Windows8 and Windows Server2012</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileAlignmentInfo">
            <summary>
            <para>File alignment information should be retrieved. Use for any handles. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfileinformationbyhandleex">GetFileInformationByHandleEx</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_alignment_info">FILE_ALIGNMENT_INFO</a>. <b>Windows Server2008R2, Windows7, Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP:</b>This value is not supported before Windows8 and Windows Server2012</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileIdInfo">
            <summary>
            <para>File information should be retrieved. Use for any handles. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfileinformationbyhandleex">GetFileInformationByHandleEx</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_info">FILE_ID_INFO</a>. <b>Windows Server2008R2, Windows7, Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP:</b>This value is not supported before Windows8 and Windows Server2012</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileIdExtdDirectoryInfo">
            <summary>
            <para>Files in the specified directory should be retrieved. Used for directory handles. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfileinformationbyhandleex">GetFileInformationByHandleEx</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_extd_dir_info">FILE_ID_EXTD_DIR_INFO</a>. <b>Windows Server2008R2, Windows7, Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP:</b>This value is not supported before Windows8 and Windows Server2012</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileIdExtdDirectoryRestartInfo">
            <summary>
            <para>Identical to <b>FileIdExtdDirectoryInfo</b>, but forces the enumeration operation to start again from the beginning. Use only when calling <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfileinformationbyhandleex">GetFileInformationByHandleEx</a>. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_extd_dir_info">FILE_ID_EXTD_DIR_INFO</a>. <b>Windows Server2008R2, Windows7, Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP:</b>This value is not supported before Windows8 and Windows Server2012</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//minwinbase/ne-minwinbase-file_info_by_handle_class#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileDispositionInfoEx">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.FileRenameInfoEx">
            <summary></summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS.MaximumFileInfoByHandleClass">
            <summary>This value is used for validation. Supported values are less than this value.</summary>
        </member>
        <member name="T:Windows.Win32.Storage.FileSystem.FILE_RENAME_INFO">
            <summary>Contains the name to which the file should be renamed.</summary>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/ns-winbase-file_rename_info">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_RENAME_INFO.RootDirectory">
            <summary>A handle to the root directory in which the file to be renamed is located.</summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_RENAME_INFO.FileNameLength">
            <summary>The size of <b>FileName</b> in bytes.</summary>
        </member>
        <member name="F:Windows.Win32.Storage.FileSystem.FILE_RENAME_INFO.FileName">
            <summary>The new file name.</summary>
        </member>
        <member name="P:Windows.Win32.Storage.FileSystem.FILE_RENAME_INFO.__char_1.Length">
            <summary>Always <c>1</c>.</summary>
        </member>
        <member name="M:Windows.Win32.Storage.FileSystem.FILE_RENAME_INFO.__char_1.ToString(System.Int32)">
            <summary>
            Copies the fixed array to a new string up to the specified length regardless of whether there are null terminating characters.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when <paramref name="length" /> is less than <c>0</c> or greater than <see cref="P:Windows.Win32.Storage.FileSystem.FILE_RENAME_INFO.__char_1.Length" />.
            </exception>
        </member>
        <member name="M:Windows.Win32.Storage.FileSystem.FILE_RENAME_INFO.__char_1.ToString">
            <summary>
            Copies the fixed array to a new string, stopping before the first null terminator character or at the end of the fixed array (whichever is shorter).
            </summary>
        </member>
        <member name="T:Windows.Win32.PInvoke">
            <content>
            Contains extern methods from "Kernel32.dll".
            </content>
        </member>
        <member name="M:Windows.Win32.PInvoke.CloseHandle(Windows.Win32.Foundation.HANDLE)">
            <summary>Closes an open object handle.</summary>
            <param name="hObject">A valid handle to an open object.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the application is running under a debugger,  the function will throw an exception if it receives either a  handle value that is not valid  or a pseudo-handle value. This can happen if you close a handle twice, or if you  call <b>CloseHandle</b> on a handle returned by the <a href="/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> function instead of calling the <a href="/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.</para>
            </returns>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//handleapi/nf-handleapi-closehandle">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CreateFile(System.String,Windows.Win32.Storage.FileSystem.FILE_ACCESS_FLAGS,Windows.Win32.Storage.FileSystem.FILE_SHARE_MODE,System.Nullable{Windows.Win32.Security.SECURITY_ATTRIBUTES},Windows.Win32.Storage.FileSystem.FILE_CREATION_DISPOSITION,Windows.Win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES,System.Runtime.InteropServices.SafeHandle)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.CreateFile(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Storage.FileSystem.FILE_ACCESS_FLAGS,Windows.Win32.Storage.FileSystem.FILE_SHARE_MODE,Windows.Win32.Security.SECURITY_ATTRIBUTES*,Windows.Win32.Storage.FileSystem.FILE_CREATION_DISPOSITION,Windows.Win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES,Windows.Win32.Foundation.HANDLE)" />
        </member>
        <member name="M:Windows.Win32.PInvoke.CreateFile(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Storage.FileSystem.FILE_ACCESS_FLAGS,Windows.Win32.Storage.FileSystem.FILE_SHARE_MODE,Windows.Win32.Security.SECURITY_ATTRIBUTES*,Windows.Win32.Storage.FileSystem.FILE_CREATION_DISPOSITION,Windows.Win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES,Windows.Win32.Foundation.HANDLE)">
            <summary>Creates or opens a file or I/O device. The most commonly used I/O devices are as follows:\_file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe.</summary>
            <param name="lpFileName">
            <para>The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\\) in this name. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, use this Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>. For information on special device names, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>. To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>. <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div> </div></para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwDesiredAccess">
            <para>The requested access to the file or device, which can be summarized as read, write, both or neither zero). The most commonly used values are <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, or both (<c>GENERIC_READ | GENERIC_WRITE</c>). For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a>, <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>, <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-access-rights-constants">File Access Rights Constants</a>, and <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-mask">ACCESS_MASK</a>. If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if <b>GENERIC_READ</b> access would have been denied. You cannot request an access mode that conflicts with the sharing mode that is specified by the <i>dwShareMode</i> parameter in an open request that already has an open handle. For more information, see the Remarks section of this topic and <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwShareMode">
            <para>The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag. If this parameter is zero and <b>CreateFile</b> succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. For more information, see the Remarks section. You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. <b>CreateFile</b> would fail and the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function would return <b>ERROR_SHARING_VIOLATION</b>. To enable a process to share a file or device while another process has the file or device open, use a</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpSecurityAttributes">
            <para>A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that contains two separate but related data members: an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes. This parameter can be <b>NULL</b>. If this parameter is <b>NULL</b>, the handle returned by <b>CreateFile</b> cannot be inherited by any child processes the application may create and the file or device associated with the returned handle gets a default security descriptor. The <b>lpSecurityDescriptor</b> member of the structure specifies a <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> for a file or device. If this member is <b>NULL</b>, the file or device associated with the returned handle is assigned a default security descriptor. <b>CreateFile</b> ignores the <b>lpSecurityDescriptor</b> member when opening an existing file or device, but continues to use the <b>bInheritHandle</b> member. The <b>bInheritHandle</b>member of the structure specifies whether the returned handle can be inherited. For more information, see the Remarks section.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwCreationDisposition">
            <para>An action to take on a file or device that exists or does not exist. For devices other than files, this parameter is usually set to <b>OPEN_EXISTING</b>. For more information, see the Remarks section.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwFlagsAndAttributes">
            <para>The file or device attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most common default value for files. This parameter can include any combination of the available file attributes (<b>FILE_ATTRIBUTE_*</b>). All other file attributes override <b>FILE_ATTRIBUTE_NORMAL</b>. This parameter can also contain combinations of flags (<b>FILE_FLAG_*</b>) for control of file or device caching behavior, access modes, and other special-purpose flags. These combine with any <b>FILE_ATTRIBUTE_*</b> values. This parameter can also contain Security Quality of Service (SQOS) information by specifying the <b>SECURITY_SQOS_PRESENT</b> flag. Additional SQOS-related flags information is presented in the table following the attributes and flags tables. <div class="alert"><b>Note</b>  When <b>CreateFile</b> opens an existing file, it generally combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied as part of <i>dwFlagsAndAttributes</i>. Special cases are detailed in <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</div> <div> </div> Some of the following file attributes and flags may only apply to files and not necessarily all other types of devices that <b>CreateFile</b> can open. For additional information, see the Remarks section of this topic and <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>. For more advanced access to file attributes, see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributes</a>. For a complete list of all file attributes with their values and descriptions, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="hTemplateFile">
            <para>A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template file supplies file attributes and extended attributes for the file that is being created. This parameter can be <b>NULL</b>. When opening an existing file, <b>CreateFile</b> ignores this parameter. When opening a new encrypted file, the file inherits the discretionary access control list from its parent directory. For additional information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot. If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilew">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CreateHardLink(System.String,System.String,Windows.Win32.Security.SECURITY_ATTRIBUTES@)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.CreateHardLink(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Security.SECURITY_ATTRIBUTES*)" />
        </member>
        <member name="M:Windows.Win32.PInvoke.CreateHardLink(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Security.SECURITY_ATTRIBUTES*)">
            <summary>Establishes a hard link between an existing file and a new file.</summary>
            <param name="lpFileName">
            <para>The name of the new file.</para>
            <para>This parameter may include the path but cannot specify the name of a directory. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND. <div class="alert"><b>Tip</b>Starting with Windows10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div></div></para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createhardlinkw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpExistingFileName">
            <para>The name of the existing file.</para>
            <para>This parameter may include the path cannot specify the name of a directory. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND. <div class="alert"><b>Tip</b>Starting with Windows10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div></div></para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createhardlinkw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpSecurityAttributes">Reserved; must be <b>NULL</b>.</param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results. If you pass a name longer than MAX_PATH characters to the *lpFileName* or *lpExistingFileName* parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND.</para>
            </returns>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createhardlinkw">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CreateSymbolicLink(System.String,System.String,Windows.Win32.Storage.FileSystem.SYMBOLIC_LINK_FLAGS)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.CreateSymbolicLink(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Storage.FileSystem.SYMBOLIC_LINK_FLAGS)" />
        </member>
        <member name="M:Windows.Win32.PInvoke.CreateSymbolicLink(Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Storage.FileSystem.SYMBOLIC_LINK_FLAGS)">
            <summary>Creates a symbolic link.</summary>
            <param name="lpSymlinkFileName">
            <para>The symbolic link to be created. This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. <div class="alert"><b>Tip</b>Starting with Windows10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div></div></para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createsymboliclinkw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpTargetFileName">
            <para>The name of the target for the symbolic link to be created. If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as an absolute link; otherwise, the link is treated as a relative link. This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. <div class="alert"><b>Tip</b>Starting with Windows10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div> <div></div></para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createsymboliclinkw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwFlags">
            <para>Indicates whether the link target, <i>lpTargetFileName</i>, is a directory. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createsymboliclinkw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createsymboliclinkw">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetFileInformationByHandle(System.Runtime.InteropServices.SafeHandle,Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION@)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.GetFileInformationByHandle(Windows.Win32.Foundation.HANDLE,Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION*)" />
        </member>
        <member name="M:Windows.Win32.PInvoke.GetFileInformationByHandle(Windows.Win32.Foundation.HANDLE,Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION*)">
            <summary>Retrieves file information for the specified file.</summary>
            <param name="hFile">
            <para>A handle to the file that contains the information to be retrieved. This handle should not be a pipe handle.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfileinformationbyhandle#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpFileInformation">
            <para>A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-by_handle_file_information">BY_HANDLE_FILE_INFORMATION</a> structure that receives the file information.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfileinformationbyhandle#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero and file information data is contained in the buffer pointed to by the <i>lpFileInformation</i> parameter. If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfileinformationbyhandle">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetFinalPathNameByHandle(System.Runtime.InteropServices.SafeHandle,Windows.Win32.Foundation.PWSTR,System.UInt32,Windows.Win32.Storage.FileSystem.FILE_NAME)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.GetFinalPathNameByHandle(Windows.Win32.Foundation.HANDLE,Windows.Win32.Foundation.PWSTR,System.UInt32,Windows.Win32.Storage.FileSystem.FILE_NAME)" />
        </member>
        <member name="M:Windows.Win32.PInvoke.GetFinalPathNameByHandle(Windows.Win32.Foundation.HANDLE,Windows.Win32.Foundation.PWSTR,System.UInt32,Windows.Win32.Storage.FileSystem.FILE_NAME)">
            <summary>Retrieves the final path for the specified file.</summary>
            <param name="hFile">A handle to a file or directory.</param>
            <param name="lpszFilePath">A pointer to a buffer that receives the path of <i>hFile</i>.</param>
            <param name="cchFilePath">The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.</param>
            <param name="dwFlags"></param>
            <returns>
            <para>If the function succeeds, the return value is the length of the string received by <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the size of the terminating null character. <b>Windows Server2008 and WindowsVista:</b>For the ANSI version of this function, <b>GetFinalPathNameByHandleA</b>, the return value includes the size of the terminating null character. If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the terminating null character, the return value is the required buffer size, in <b>TCHAR</b>s. This value includes the size of the terminating null character. If the function fails for any other reason, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfinalpathnamebyhandlew">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.ReOpenFile(System.Runtime.InteropServices.SafeHandle,Windows.Win32.Storage.FileSystem.FILE_ACCESS_FLAGS,Windows.Win32.Storage.FileSystem.FILE_SHARE_MODE,Windows.Win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.ReOpenFile(Windows.Win32.Foundation.HANDLE,Windows.Win32.Storage.FileSystem.FILE_ACCESS_FLAGS,Windows.Win32.Storage.FileSystem.FILE_SHARE_MODE,Windows.Win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES)" />
        </member>
        <member name="M:Windows.Win32.PInvoke.ReOpenFile(Windows.Win32.Foundation.HANDLE,Windows.Win32.Storage.FileSystem.FILE_ACCESS_FLAGS,Windows.Win32.Storage.FileSystem.FILE_SHARE_MODE,Windows.Win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES)">
            <summary>Reopens the specified file system object with different access rights, sharing mode, and flags.</summary>
            <param name="hOriginalFile">
            <para>A handle to the object to be reopened. The object must have been created by the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-reopenfile#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwDesiredAccess">
            <para>The required access to the object. For a list of values, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>. You cannot request an access mode that conflicts with the sharing mode specified in a previous open request whose handle is still open. If this parameter is zero (0), the application can query device attributes without accessing the device. This is useful if an application wants to determine the size of a floppy disk drive and the formats it supports without requiring a floppy in the drive.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-reopenfile#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwShareMode">
            <para>The sharing mode of the object. You cannot request a sharing mode that conflicts with the access mode specified in a previous open request whose handle is still open. If this parameter is zero (0) and <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> succeeds, the object cannot be shared and cannot be opened again until the handle is closed. To enable other processes to share the object while your process has it open, use a combination of one or</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-reopenfile#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwFlagsAndAttributes"></param>
            <returns>
            <para>If the function succeeds, the return value is an open handle to the specified file. If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-reopenfile">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.SetFileInformationByHandle(System.Runtime.InteropServices.SafeHandle,Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS,System.Void*,System.UInt32)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.SetFileInformationByHandle(Windows.Win32.Foundation.HANDLE,Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS,System.Void*,System.UInt32)" />
        </member>
        <member name="M:Windows.Win32.PInvoke.SetFileInformationByHandle(Windows.Win32.Foundation.HANDLE,Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS,System.Void*,System.UInt32)">
            <summary>Sets the file information for the specified file.</summary>
            <param name="hFile">
            <para>A handle to the file for which to change information. This handle must be opened with the appropriate permissions for the requested change. For more information, see the Remarks and Example Code sections. This handle should not be a pipe handle.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileinformationbyhandle#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="FileInformationClass">
            <para>A <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-file_info_by_handle_class">FILE_INFO_BY_HANDLE_CLASS</a> enumeration value that specifies the type of information to be changed. For a table of valid values, see the Remarks section.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileinformationbyhandle#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpFileInformation">
            <para>A pointer to the buffer that contains the information to change  for the specified file information class. The structure that this parameter points to corresponds to the class that is specified by <i>FileInformationClass</i>. For a table of valid structure types, see the Remarks section.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileinformationbyhandle#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwBufferSize">The size of <i>lpFileInformation</i>, in bytes.</param>
            <returns>
            <para>Returns nonzero if successful or zero otherwise. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileinformationbyhandle">Learn more about this API from docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="T:Windows.Win32.Security.SECURITY_ATTRIBUTES">
            <summary>The SECURITY_ATTRIBUTES structure contains the security descriptor for an object and specifies whether the handle retrieved by specifying this structure is inheritable.</summary>
            <remarks>
            <para><see href="https://docs.microsoft.com/windows/win32/api//wtypesbase/ns-wtypesbase-security_attributes#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="F:Windows.Win32.Security.SECURITY_ATTRIBUTES.nLength">
            <summary>The size, in bytes, of this structure. Set this value to the size of the **SECURITY\_ATTRIBUTES** structure.</summary>
        </member>
        <member name="F:Windows.Win32.Security.SECURITY_ATTRIBUTES.lpSecurityDescriptor">
            <summary>
            <para>A pointer to a [**SECURITY\_DESCRIPTOR**](../winnt/ns-winnt-security_descriptor.md) structure that controls access to the object. If the value of this member is **NULL**, the object is assigned the default security descriptor associated with the [*access token*](/windows/win32/secauthz/access-tokens) of the calling process. This is not the same as granting access to everyone by assigning a **NULL**[*discretionary access control list*](/windows/win32/secauthz/dacls-and-aces) (DACL). By default, the default DACL in the access token of a process allows access only to the user represented by the access token. For information about creating a security descriptor, see [Creating a Security Descriptor](/windows/win32/secauthz/creating-a-security-descriptor-for-a-new-object-in-c--).</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api//wtypesbase/ns-wtypesbase-security_attributes#members">Read more on docs.microsoft.com</see>.</para>
            </summary>
        </member>
        <member name="F:Windows.Win32.Security.SECURITY_ATTRIBUTES.bInheritHandle">
            <summary>A Boolean value that specifies whether the returned handle is inherited when a new process is created. If this member is **TRUE**, the new process inherits the handle.</summary>
        </member>
    </members>
<Signature xmlns="http://www.w3.org/2000/09/xmldsig#"><SignedInfo><CanonicalizationMethod Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" /><SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256" /><Reference URI=""><Transforms><Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature" /><Transform Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" /></Transforms><DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256" /><DigestValue>9n/utdK6kBi08mBvOE6V/89Jc8ODc9jHjUjGC5JOcuw=</DigestValue></Reference></SignedInfo><SignatureValue>etUuH8EdokkBb2pDAH1t6hpb1S/Xf1C8UI3De32zaIl1tbXayTdXKvLuY8ODVBqx11Ks+NgyyUKuzx+5janW5SpnIUU/cvhVDpgSAwB9HOPvcy1jmDanjiOWxuQU160xDF+qhzNtEkfcOYH+Rp6DqE2AlmgTE/hTwoA8UUc4qRHkUsctVC28AslKWUv24lGbcq7Zg8Is1WCgOxUfibl22i7HESHAsU9oKyXtfFywAPXwNevJDhgJXv1WpCnrta+kAp4X8cMQwx2cM8ufCRCeQPn4wiBW2J7GP3l0N9zh8FAC/Sw1HWsJhy+kcnQ8VyO198PokNxS3kEmVqBeEAzNYw==</SignatureValue><KeyInfo><KeyValue><RSAKeyValue><Modulus>zkvLNa2un9GBrYNDoRGkGv7d0PqtTBB4ViYakFbjuWpmF0KcvDAzzaCWJPhVgIXjz+S8cHEoHuWnp/n+UOljT3ehA8Rs6Lb1aTYub3tB/e0txewv2sQ3yscjYdtTBtFvEm9L8Yv76K3Cxzi/Yvrdg+sr7w8y5RHn1Am0Ff8xggY1xpWCXFI+kQM18njQDcUqSlwBnexYfqHBhzz6YXA/S0EziYBu2O2mM7R6gSyYkEOHgIGTVOGnOvvC5xBgC4KNcnQuQSRLiUI2CmzU8vefR6ykruyzt1rNMPI8OqWHQtSDKXU5JNqbk4GNjwzcwbSzOHrxuxWHq91l/vLdVDGDUw==</Modulus><Exponent>AQAB</Exponent></RSAKeyValue></KeyValue><X509Data><X509Certificate>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</X509Certificate><X509Certificate>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</X509Certificate><X509Certificate>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</X509Certificate></X509Data></KeyInfo><Object Id="ts-countersig"><X509Data><X509Certificate>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</X509Certificate><X509Certificate>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</X509Certificate></X509Data><CounterSignature ts-format="cms-timestamp-message" xmlns="http://schemas.microsoft.com/xmldsig/timestamp/2003">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</CounterSignature></Object></Signature></doc>
